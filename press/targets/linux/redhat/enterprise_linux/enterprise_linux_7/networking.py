import logging
import uuid

from press import helpers

from collections import OrderedDict
from press.helpers.package import get_press_version


# TODO: Form base class for sysconfig/network-scripts under redhat

log = logging.getLogger(__name__)

# Type: func
lookup_methods = {'mac': helpers.networking.get_device_by_mac,
                  'dev': helpers.networking.get_device_by_dev}


class InterfaceTemplate(OrderedDict):
    def __init__(self,
                 device,
                 type='Ethernet',
                 bootproto='none',
                 default_route=False,
                 ipv4_failure_fatal=False,
                 ipv6init=True,
                 ipv6_autoconf=False,
                 ipv6_failure_fatal=False,
                 uid='',
                 name='',
                 on_boot=True,
                 ip_address='',
                 cidr_mask='',
                 gateway='',
                 nameservers=(),
                 domain='',
                 peer_dns=False):
        super(InterfaceTemplate, self).__init__()
        self['DEVICE'] = device
        self['NAME'] = name or device
        self['TYPE'] = type
        self['BOOTPROTO'] = bootproto
        self['DEFROUTE'] = self.yes_no(default_route)
        self['IPV4_FAILURE_FATAL'] = self.yes_no(ipv4_failure_fatal)
        self['IPV6INIT'] = self.yes_no(ipv6init)
        self['IPV6_AUTOCONF'] = self.yes_no(ipv6_autoconf)
        self['IPV6_FAILURE_FATAL'] = self.yes_no(ipv6_failure_fatal)
        if not uid:
            uid = str(uuid.uuid4())
        self['UUID'] = uid
        self['ONBOOT'] = self.yes_no(on_boot)
        self['PEERDNS'] = self.yes_no(peer_dns)
        self['IPV6_PEERDNS'] = self.yes_no(peer_dns)

        if ip_address:
            self['IPADDR'] = ip_address
            self['PREFIX'] = cidr_mask

        if gateway:
            self['GATEWAY'] = gateway

        for idx in range(len(nameservers)):
            self['DNS%d' % idx] = nameservers[idx]

        if domain:
            self['DOMAIN'] = domain

    def generate(self):
        script = '# Generated by press v%s\n' % get_press_version()
        for k, v in self.items():
            script += '%s=%s\n' % (k, v)
        return script

    @staticmethod
    def yes_no(b):
        return b and 'yes' or 'no'


def generate_routes(routes):
    script = '# Generated by press v%s\n' % get_press_version()
    d = OrderedDict()
    for idx in range(len(routes)):
        net, mask = helpers.networking.get_network(routes[idx]['cidr'])
        d['ADDRESS%d' % idx] = net
        d['NETMASK%d' % idx] = mask
        d['GATEWAY%d' % idx] = routes[idx]['gateway']
    for k, v in d.items():
        script += '%s=%s\n' % (k, v)
    return script

