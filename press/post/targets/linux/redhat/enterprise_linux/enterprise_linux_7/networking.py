import logging
import uuid

from press import helpers

from collections import OrderedDict
from press.helpers.package import get_press_version


# TODO: Form base class for sysconfig/network-scripts under redhat

log = logging.getLogger(__name__)

# Type: func
lookup_methods = {'mac': helpers.networking.get_device_by_mac,
                  'dev': helpers.networking.get_device_by_dev}


class NetworkConfigurationException(Exception):
    pass


class InterfaceTemplate(OrderedDict):
    def __init__(self,
                 device,
                 type='Ethernet',
                 bootproto='none',
                 default_route=False,
                 ipv4_failure_fatal=False,
                 ipv6init=True,
                 ipv6_autoconf=True,
                 ipv6_failure_fatal=False,
                 uid='',
                 name='',
                 on_boot=True,
                 ip_address='',
                 cidr_mask='',
                 gateway='',
                 nameservers=(),
                 domain='',
                 peer_dns=False):
        super(InterfaceTemplate, self).__init__()
        self['DEVICE'] = device
        self['NAME'] = name or device
        self['TYPE'] = type
        self['BOOTPROTO'] = bootproto
        self['DEFROUTE'] = self.yes_no(default_route)
        self['IPV4_FAILURE_FATAL'] = self.yes_no(ipv4_failure_fatal)
        self['IPV6INIT'] = self.yes_no(ipv6init)
        self['IPV6_AUTOCONF'] = self.yes_no(ipv6_autoconf)
        self['IPV6_FAILURE_FATAL'] = self.yes_no(ipv6_failure_fatal)
        if not uid:
            uid = str(uuid.uuid4())
        self['UUID'] = uid
        self['ONBOOT'] = self.yes_no(on_boot)
        self['PEERDNS'] = self.yes_no(peer_dns)

        if ip_address:
            self['IPADDR'] = ip_address
            self['PREFIX'] = cidr_mask

        if gateway:
            self['GATEWAY'] = gateway

        for idx in range(len(nameservers)):
            self['DNS%d' % idx] = nameservers[idx]

        if domain:
            self['DOMAIN'] = domain

    def generate(self):
        script = '# Generated by press v%s\n' % get_press_version()
        for k, v in self.items():
            script += '%s=%s\n' % (k, v)
        return script

    @staticmethod
    def yes_no(b):
        return b and 'yes' or 'no'


def generate_routes(routes):
    script = '# Generated by press v%s\n' % get_press_version()
    d = OrderedDict()
    for idx in range(len(routes)):
        net, mask = helpers.networking.get_network(routes[idx]['cidr'])
        d['ADDRESS%d' % idx] = net
        d['NETMASK%d' % idx] = mask
        d['GATEWAY%d' % idx] = routes[idx]['gateway']
    for k, v in d.items():
        script += '%s=%s\n' % (k, v)
    return script

def lookup_interface(interface, dev_missing_ok=False):
    """
    This function is transitory, Network configuration will be re-worked in 0.4
    :param interface:
    :return:
    """
    ref = interface['ref']
    lookup_method = lookup_methods.get(ref['type'])
    if not lookup_method:
        raise NetworkConfigurationException('Press 0.3 Network configuration error, missing type')
    ndi = lookup_method(ref['value'])
    if not ndi:
        if ref['type'] == 'dev' and dev_missing_ok:
            class Duck(object):
                devname = ref['value']
            ndi = Duck
            log.warn('Duck typing an NetDeviceInfo object, %s does not seem to exist' % ref['value'])
        else:
            raise NetworkConfigurationException('Press 0.3 Could not find device: %s' % ref['value'])
    return interface['name'], ndi